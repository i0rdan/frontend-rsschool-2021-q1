function calculateStringLength (str) {
    let result = str.split(' ').map(function(oneStr) {
        return oneStr + ' ' + oneStr.toString().length;
    });
    return result;
}

console.log(calculateStringLength('sdd sff s'));

function letterToNumber (str) {
    let index = 0;
    let mas = [];
    str = str.toLowerCase();
    for(let i = 0; i < str.length; i++){
        if(isNaN(str[i]))  {
            for (let j = 0; j < str.length; j++){
                if(str[i] == str[j] && isNaN(str[j])) mas[j] = index;
            }
            str = str.split(str[i]).join(index);
            index += 1;
        }
    }
    return mas.join('.');
}

console.log(letterToNumber('hello'));

function bracketDuplicate (str) {
    if(typeof str === 'string') return str.replace(/(.)\1(\1+)/g, '$1$1[$2]');
    else return 'Please enter a valid string';
}

console.log(bracketDuplicate('heeeelllooo'));

console.log(1-'0'+2); /*Выражение выполняется слева направо '0' приводится к числу, поскольку перед
оператор вычитания в итоге получаем 1 - 0 + 2 = 3;*/
console.log(1-'-0'+2); /*В данном случае строка приводится к -0, который равен 0, получается
1 - 0 + 2*/
console.log(1-'0-'+'NaN'); /*Результатом выражения является NaNNaN, поскольку при вычитании строки '-0-',
она не преобразуется к 0, потому что есть - после нуля, при вычитании из числа строки получаем NaN, 
далее к NaN прибавляем 'NaN', когда прибавляем к строке все преобразуется к строке и складывается. Итог NaNNaN*/
console.log('b' + [NaN + 'ba', 'CC'] - {}); /*В результате получим NaN, поскольку при сложении массив преобразуется
в строку, получаем следующее выражение bNaNbaCC(при сложении NaN с строкой NaN преобразуется в строку). Далее
необходимо из строки bNaNbaCC отнять обьект, который преобразуется к строке, поскольку есть оператор вычитания.
При вычитании из одной строки другой получаем NaN*/
console.log([] + (()=>{})); /*В результате получаем ()=>{}, массив при сложении преобразуется к строке,
т.к массив пустой получаем пустую строку '' + (()=>{}). Содержимое в скобках тоже преобразуется в строку, в 
итоге получаем результат сложения двух строк*/
console.log([] + (()=>{})()); /*Результат ()=>({}), добавляются скобки. Основная идея как и в предыдущем*/
console.log([] + (()=>({})()));/*Результатом является [object Object] поскольку стрелочная функция
(()=>({}))() при выполнении возвращает обьект. получаем [] + {}, все преобразуется к строке, пустой массив в
'', а обьект в [object Object], далее строки складываются*/
console.log([] + (()=>new Object(123))());/*Результатом выполнения функции является 123, поскольку функиция 
возвращет 123 и при сложении с массивом, массив преобразуется к 0 и 0 + 123 = 123*/
console.log({} + (()=>new Object(123))());/*Результатом выполнения функции является [object Object]123, поскольку функиция 
возвращет 123 и при сложении с обьектом, обьект преобразуется к [object Object] и далее получаем [object Object] +
+ 123, все приводится к строке*/
console.log((()=>new Object(123))() + {}); /* То же самое, что и в предыдущем выражении, только 123 + [object Object]
получается 123[object Object]*/
console.log(({}).valueOf() + 1); /*результатом выражения является [object Object]1, поскольку метод valueOf(), 
возвращает в данном случае пустой обьект, получаем {} + 1, все приводится к строке {} к [object Object], 1 к 1.
Результатом является сложение [object Object]1*/
console.log({} + 2 );/*При сложении приводится к строке обьект и 2, получаем [object Object]2*/
console.log(typeof({}).valueOf() + 2); /*typeof({}) = object. object.valueOf() вернет object. В итоге получим
object + 2, приводится к строке все, получаем object2*/
console.log(+{}); /* операнд + приводит обьект к числу, но в результате приведения получается NaN, поскольку нельзя
привести обьект к числу*/
console.log(+{} + []); /* операнд + приводит обьект к числу, но в результате приведения получается NaN, поскольку нельзя
привести обьект к числу далее получаем NaN + []. Все приводится к строкам, получаем 'NaN' + '', полуаем NaN*/
console.log(+[]); /* операнд + приводит обьект, который является массивом к числу, но в результате приведения получается 0,
поскольку массив пустой*/
console.log(+[] + {});/*Из предыдущего выражение массив приводится к 0, далее получаем 0 + {}, всеприводится к строкам
получаем 0[object Object]*/
console.log(+[10,1] + {});/*В результате приведения массива получаем NaN, поскольку в массиве несколько элементов
+[10] = 10, +[1,2] = NaN, получим NaN + {}, приводится к строкам и получается NaN[object, Object]*/
console.log(+{} + [10]);/* операнд + приводит обьект к числу, но в результате приведения получается NaN, поскольку нельзя
привести обьект к числу, далее массив приводится к строке получаем 'NaN' + '10' = NaN10*/
console.log(0 == null);/*Выдаст false поскольку null равен только сам себе и undefined*/
console.log(undefined == null);/* это специальное правило языка. результат true.хотя  undefined === null false*/
console.log(1 == {});/*При сравнении с обьектом обьект преобразуется к числу, в результате преобразования 
получаем NaN, т.к NaN != 1, вернет false*/
console.log(1 == ({}));/*При сравнении с обьектом обьект преобразуется к числу, в результате преобразования 
получаем NaN, т.к NaN != 1, вернет false*/
console.log({} == 1);/*При сравнении с обьектом обьект преобразуется к числу, в результате преобразования 
получаем NaN, т.к NaN != 1, вернет false*/
console.log(({toString: () => '12'}) == 12);/*Результатом функции является строка '12', число 12 преобразуется
в строку при сравнении, получаем true*/

